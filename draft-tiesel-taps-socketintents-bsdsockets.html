<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>A Socket Intents Prototype for the BSD Socket API &#8211; Experiences, Lessons Learned and Considerations</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Prototype Architecture">
<link href="#rfc.section.3" rel="Chapter" title="3 Multiple Access Manager">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Policy">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Path characteristics data collectors">
<link href="#rfc.section.4" rel="Chapter" title="4 Socket Intents Representation">
<link href="#rfc.section.5" rel="Chapter" title="5 The Socket Intents API Variants">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Classic API / muacc_context">
<link href="#rfc.section.5.1.1" rel="Chapter" title="5.1.1 muacc_getaddrinfo()">
<link href="#rfc.section.5.1.2" rel="Chapter" title="5.1.2 muacc_socket()">
<link href="#rfc.section.5.1.3" rel="Chapter" title="5.1.3 muacc_setsockopt()">
<link href="#rfc.section.5.1.4" rel="Chapter" title="5.1.4 muacc_connect()">
<link href="#rfc.section.5.1.5" rel="Chapter" title="5.1.5 muacc_close()">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Classic API / getaddrinfo">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Socketconnect API">
<link href="#rfc.section.6" rel="Chapter" title="6 API Implementation Experiences &amp; Lessons Learned">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 The Missing Link to Name Resolution">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 File Descriptors Considered Harmful">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Asynchronous API Anarchy">
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 Here Be Dragons hiding in Shadow Structures">
<link href="#rfc.section.7" rel="Chapter" title="7 Conclusion">
<link href="#rfc.section.8" rel="Chapter" title="8 Acknowledgments">
<link href="#rfc.references" rel="Chapter" title="9 Informative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A API Usage Examples">
<link href="#rfc.appendix.A.1" rel="Chapter" title="A.1 Usage Example of the Classic / muacc_context API">
<link href="#rfc.appendix.A.2" rel="Chapter" title="A.2 Usage Example of the Classic / getaddrinfo API">
<link href="#rfc.appendix.A.3" rel="Chapter" title="A.3 Usage Example of the Socketconnect API">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.6.2 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Tiesel, P. and T. Enghardt" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-tiesel-taps-socketintents-bsdsockets-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2017-7-03" />
  <meta name="dct.abstract" content="This document describes a prototype implementation of Socket Intents " />
  <meta name="description" content="This document describes a prototype implementation of Socket Intents " />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">TAPS Working Group</td>
<td class="right">P. Tiesel</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">T. Enghardt</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">Berlin Institute of Technology</td>
</tr>
<tr>
<td class="left">Expires: January 4, 2018</td>
<td class="right">July 03, 2017</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">A Socket Intents Prototype for the BSD Socket API &#8211; Experiences, Lessons Learned and Considerations<br />
  <span class="filename">draft-tiesel-taps-socketintents-bsdsockets-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document describes a prototype implementation of Socket Intents <a href="#I-D.tiesel-taps-socketintents" class="xref">[I-D.tiesel-taps-socketintents]</a> for the BSD Socket API as an illustrative example how Socket Intents could be implemented.  It described the experiences made with the prototype and lessons learned from trying to extend the BSD Socket API.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on January 4, 2018.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2017 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Prototype Architecture</a>
</li>
<li>3.   <a href="#rfc.section.3">Multiple Access Manager</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Policy</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Path characteristics data collectors</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">Socket Intents Representation</a>
</li>
<li>5.   <a href="#rfc.section.5">The Socket Intents API Variants</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Classic API / muacc_context</a>
</li>
<ul><li>5.1.1.   <a href="#rfc.section.5.1.1">muacc_getaddrinfo()</a>
</li>
<li>5.1.2.   <a href="#rfc.section.5.1.2">muacc_socket()</a>
</li>
<li>5.1.3.   <a href="#rfc.section.5.1.3">muacc_setsockopt()</a>
</li>
<li>5.1.4.   <a href="#rfc.section.5.1.4">muacc_connect()</a>
</li>
<li>5.1.5.   <a href="#rfc.section.5.1.5">muacc_close()</a>
</li>
</ul><li>5.2.   <a href="#rfc.section.5.2">Classic API / getaddrinfo</a>
</li>
<li>5.3.   <a href="#rfc.section.5.3">Socketconnect API</a>
</li>
</ul><li>6.   <a href="#rfc.section.6">API Implementation Experiences &amp; Lessons Learned</a>
</li>
<ul><li>6.1.   <a href="#rfc.section.6.1">The Missing Link to Name Resolution</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">File Descriptors Considered Harmful</a>
</li>
<li>6.3.   <a href="#rfc.section.6.3">Asynchronous API Anarchy</a>
</li>
<li>6.4.   <a href="#rfc.section.6.4">Here Be Dragons hiding in Shadow Structures</a>
</li>
</ul><li>7.   <a href="#rfc.section.7">Conclusion</a>
</li>
<li>8.   <a href="#rfc.section.8">Acknowledgments</a>
</li>
<li>9.   <a href="#rfc.references">Informative References</a>
</li>
<li>Appendix A.   <a href="#rfc.appendix.A">API Usage Examples</a>
</li>
<ul><li>A.1.   <a href="#rfc.appendix.A.1">Usage Example of the Classic / muacc_context API</a>
</li>
<li>A.2.   <a href="#rfc.appendix.A.2">Usage Example of the Classic / getaddrinfo API</a>
</li>
<li>A.3.   <a href="#rfc.appendix.A.3">Usage Example of the Socketconnect API</a>
</li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">With the proliferation of devices that have multiple paths to the internet and an increasing number of transport protocols available, the number of transport options to serve a communication unit explodes.  Implementing a heuristic or strategy for choosing from this overwhelming set of transport options by each application puts a huge burden on the application developer.  Thus, the decisions regarding all transport options mentioned so far should be supported and, if requested by the application, automated within the transport layer.</p>
<p id="rfc.section.1.p.2">Socket Intents <a href="#I-D.tiesel-taps-socketintents" class="xref">[I-D.tiesel-taps-socketintents]</a> allow an application to express what it knows, assumes, expects or wants to prioritize regarding its own network communication.  This information can than be used by the OS to perform destination selection, path selection and transport protocol stack instance selection.</p>
<p id="rfc.section.1.p.3">Our Socket Intents prototype for the BSD Socket API is a first attempt to automate transport option selection within the OS.  It is primarily targeted at path and destination address selection and tries to be as close as possible to the semantics of the BSD Socket API.  The prototype mostly excludes the problem of transport protocol stack instance selection, which is more closely discussed in <a href="#I-D.tiesel-taps-communitgrany" class="xref">[I-D.tiesel-taps-communitgrany]</a>.</p>
<p id="rfc.section.1.p.4">We implemented the prototype as a wrapper for the BSD Socket API that communicates to a central Multiple Access Manager that makes the actual decisions and can optimize across applications.  The whole implementation was done in about 15k lines of C code.  The code is available at <a href="https://github.com/fg-inet/socket-intents/">Github</a> under BSD License.</p>
<p id="rfc.section.1.p.5">This document describes our Socket Intents prototype for the BSD Socket API.  It details important aspects of the implementation and the API variants we developed over time based on lessons learned. Finally, it summarizes these lessons and points out why the BSD Socket API is not particularly well suited to integrate automated transport protocol stack instance selection. Furthermore, it describes the limitations for destination address and path selection within the BSD Socket API.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#prototype-architecture" id="prototype-architecture">Prototype Architecture</a>
</h1>
<p id="rfc.section.2.p.1">The Socket Intents prototype consists of the following components, also shown in <a href="#prototypearch" class="xref">Figure 1</a>:</p>
<p></p>

<ul>
<li>The Socket Intents API, a BSD Socket API wrapper for applications to use, including a representation of the actual Socket Intents.</li>
<li>The Socket Intents Library which implements the Socket Intents API.  It sends requests to the Multiple Access Manager, e.g. before establishing a connection, and gets back a response regarding what interface to use.</li>
<li>The Multiple Access Manager (MAM), a daemon which gets informed about all application requests and has knowledge of the available network interfaces.</li>
<li>The Policy, a dynamically loaded library hosted by the MAM. It chooses which of the available interfaces to use based on the available knowledge about them and the Socket Intents.</li>
<li>Data collectors that that reside inside the MAM and that provide information like bandwidth usage, smoothed RTT estimate and RSSI for wireless links to the policy.</li>
</ul>
<div id="rfc.figure.1"></div>
<div id="prototypearch"></div>
<pre>
+------------------------+
|      Application       |
|                        |                   +-------------------+
+-{ Socket Intents API }-+  (MAM Request)    |  Multiple Access  |
|                        | ----------------&gt; |      Manager      |
|     Socket Intents     |  (MAM Response)   | +---------------+ |
|        Library         | &lt;---------------- | |    Policy     | |
+------------------------+                   | +---------------+ |
|      BSD Sockets       |                   | |Data Collectors| |
+------------------------+                   +-+---------------+-+
</pre>
<p class="figure">Figure 1: Components of the Socket Intents Prototype</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#multiple-access-manager" id="multiple-access-manager">Multiple Access Manager</a>
</h1>
<p id="rfc.section.3.p.1">The Multiple Access Manager (MAM) is the central transport option selection instance on a host.  It is realized as a daemon that runs in userspace and receives<br> requests from each application that uses the Socket Intents Library.</p>
<p id="rfc.section.3.p.2">The MAM hosts the Policy, which is the actual decision making component, e.g., deciding which source address and therefore which source interface to use.  Upon events, such as an application requesting to resolve a name or to connect a socket (see <a href="#apivar" class="xref">Section 5</a> for details), the Socket Intents Library issues a MAM request and the MAM invokes a callback to the policy &#8211; see <a href="#policy" class="xref">Section 3.1</a> for details - which can either communicate its decision right away or defer its decision, e.g., when it has to wait for the results of name resolution.  The results and decisions are communicated back to the Socket Intents Library through the MAM response, where they are applied to the actual socket, see also <a href="#prototypearch" class="xref">Figure 1</a>.</p>
<p id="rfc.section.3.p.3">To support the policy, the MAM maintains a list of IP prefixes that are configured on the local interfaces and available for outgoing communications.  As destination address selection and path selection are highly dependent on each other, the MAM integrates DNS resolution and maintains separate resolver configurations per prefix (see <a href="#ANRW17-MH" class="xref">[ANRW17-MH]</a> for further discussion on multiple PvDs and DNS resolution).  Furthermore, the MAM includes data collectors which periodically gather statistics on the available paths, see <a href="#pmeasure" class="xref">Section 3.2</a> for details.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#policy" id="policy">Policy</a>
</h1>
<p id="rfc.section.3.1.p.1">In the Socket Intents prototype, the Policy to select among the available transport options is hosted by the MAM, see <a href="#prototypearch" class="xref">Figure 1</a>.  We implement different interchangeable policies as dynamically loaded libraries.  In our current implementation, only one policy can be active at a given time.  When launching the MAM, the user has to choose a policy and supply a policy configuration, which can contain arbitrary data.</p>
<p id="rfc.section.3.1.p.2">Examples of policy configuration include:</p>
<p></p>

<ul>
<li>A list of IP prefixes configured on local interfaces to consider as source for the communication</li>
<li>Name server(s) to use for each of the IP prefixes</li>
<li>Preferences to instrument the policy</li>
</ul>
<p id="rfc.section.3.1.p.4">The policy is initialized with this configuration and then waits for the callback of an incoming MAM request.</p>
<p id="rfc.section.3.1.p.5">Upon a callback, the policy can use information from the MAM request, such as Socket Intents, and information available within the MAM, such as recently measured path characteristics (see <a href="#pmeasure" class="xref">Section 3.2</a>), to make decisions.</p>
<p id="rfc.section.3.1.p.6">Policy decisions can include:</p>
<p></p>

<ul>
<li>The source address(es) used for name resolution</li>
<li>How to order the results of name resolution (i.e., preferring certain IP addresses over others)</li>
<li>Picking an IP protocol version</li>
<li>Picking a transport protocol</li>
<li>Setting socket options (e.g., disable TCP Nagle)</li>
<li>Choosing a source address for the outgoing communication</li>
<li>Reusing a socket from a given socket set (only for the API variant described in <a href="#socketconnectapi" class="xref">Section 5.3</a>)</li>
</ul>
<p id="rfc.section.3.1.p.8">Note that in our current implementation, the policy is a piece of code which can in principle execute arbitrary instructions.  We assume this is acceptable for an experimental platform but would prefer an abstract description like a domain-specific language for a production system.</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#pmeasure" id="pmeasure">Path characteristics data collectors</a>
</h1>
<p id="rfc.section.3.2.p.1">The data collectors are implemented as a component of the MAM, within a callback that is executed periodically, e.g., every 100 ms. When this callback is invoked, the MAM passively gathers statistics about the current usage and properties of the available local interfaces and stores them in per-interface or per-network prefix data structures.</p>
<p id="rfc.section.3.2.p.2">Measured properties include:</p>
<p></p>

<ul>
<li>Minimum Smoothed Round Trip Time (SRTT) of current TCP connections using a network prefix, as an estimate for last-mile latency</li>
<li>Transmitted and received bytes per second over an interface within the last callback period, as an estimate for current utilization</li>
<li>Smoothed transmitted and received bytes per second over an interface, as an estimate for recent utilization</li>
<li>Maximum transmitted and received bytes per second over an interface within the last 5 minutes, as an estimate for maximum available bandwidth</li>
<li>On 802.11 interfaces, the Received Signal Strength Indicator (RSSI) of the last received frame on that interface, as an estimate for reception strength</li>
<li>On 802.11 interfaces, the modulation rate of the last received and the last transmitted unicast data frame on that interface, as an estimate for the available data transmission rate on the first hop</li>
</ul>
<p id="rfc.section.3.2.p.4">When a policy callback is invoked, the policy can use the latest measured properties to guide its decisions, see <a href="#policy" class="xref">Section 3.1</a>.</p>
<p id="rfc.section.3.2.p.5">Note that we do not perform active measurements from within the MAM to avoid overhead.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#socket-intents-representation" id="socket-intents-representation">Socket Intents Representation</a>
</h1>
<p id="rfc.section.4.p.1">As described in <a href="#I-D.tiesel-taps-socketintents" class="xref">[I-D.tiesel-taps-socketintents]</a>, Socket Intents are pieces of information about upcoming traffic. An application can share the information that it has available through the Socket Intents API.</p>
<p id="rfc.section.4.p.2">In our implementation, Socket Intents are represented as socket options for get/setsockopt on its own socket option level (SOL_INTENTS).</p>
<p id="rfc.section.4.p.3">For some of the API variants, we had to introduce socket option lists, i.e., data structures that can hold multiple socket options and therefore multiple Socket Intents.</p>
<p id="rfc.section.4.p.4">Which of these variants is actually used depends on the API variant, see <a href="#apivar" class="xref">Section 5</a>.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#apivar" id="apivar">The Socket Intents API Variants</a>
</h1>
<p id="rfc.section.5.p.1">The Socket Intents API is a wrapper around the BSD Socket API. It sends requests to the Multiple Access Manager (MAM) at certain events, e.g., before a connection is established, and applies the suggestions that it gets from the MAM, e.g., to bind to a certain local interface or to set a certain socket option.</p>
<p id="rfc.section.5.p.2">There exist different variants of this API, see <a href="#apivar" class="xref">Section 5</a>, that try to fit different concepts:</p>
<p></p>

<ul>
<li>The Classic API with muacc_context, see <a href="#muacccontextapi" class="xref">Section 5.1</a>, was attempting to stick as close as possible to the call sequence of BSD Sockets.</li>
<li>The second variant of the classic API does all transport option selection in <samp>getaddrinfo</samp>, see <a href="#getaddrinfoapi" class="xref">Section 5.2</a>.  This variant tries to simplify the implementation without deriving too much from the usage of BSD Sockets.  It minimizes the changes to the BSD Socket API, but adds additional overhead to the application.</li>
<li>The <samp>socketconnect</samp> API, see <a href="#socketconnectapi" class="xref">Section 5.3</a>, tries to automate as much functionality as possible and adds support for automating connection caching.  It replaces the usual sequence of BSD Socket API calls with a single call.</li>
</ul>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#muacccontextapi" id="muacccontextapi">Classic API / muacc_context</a>
</h1>
<p id="rfc.section.5.1.p.1">In the first variant, we add a parameter called <samp>muacc_context</samp> to the BSD Socket API calls and to getaddrinfo.  This parameter holds properties provided by the socket calls and retains them across function calls to enable automation of the connection properties by our Socket Intents Prototype.  The shadow data structures behind the <samp>muacc_context</samp> parameter are initialized by API wrapper at the time of the first call (which we assume to be muacc_getaddrinfo most of the time) with most of its fields empty.  Then within each call to our modified Socket API, it is filled with data.</p>
<p id="rfc.section.5.1.p.2">Properties include:</p>
<p></p>

<ul>
<li>Socket file descriptor</li>
<li>API calls that were already performed on this context</li>
<li>domain, type, and protocol of the socket</li>
<li>remote hostname</li>
<li>remote address</li>
<li>hints for resolving the remote address</li>
<li>local address to bind to that the application requested</li>
<li>local address to bind to that the MAM suggested</li>
<li>current socket options that were set</li>
<li>socket options suggested by MAM</li>
</ul>
<h1 id="rfc.section.5.1.1">
<a href="#rfc.section.5.1.1">5.1.1.</a> <a href="#muaccgetaddrinfo" id="muaccgetaddrinfo">muacc_getaddrinfo()</a>
</h1>
<p id="rfc.section.5.1.1.p.1">This function resolves a host name or service to an addrinfo data structure, usually containing an IP address or port.  Internally, the Socket Intents prototype sends a <samp>getaddrinfo</samp> request to the MAM, which should do the name resolution.  It can, e.g., resolve the name over multiple available interfaces at the same time, and then order the results according to a policy decision, or only return results obtained over a specific interface.</p>
<p id="rfc.section.5.1.1.p.2">SIGNATURE:</p>
<p id="rfc.section.5.1.1.p.3">int muacc_getaddrinfo(muacc_context_t *ctx, const char *hostname, const char *servname, const struct addrinfo *hints, struct addrinfo **res)</p>
<p id="rfc.section.5.1.1.p.4">ARGUMENTS:</p>
<p></p>

<dl>
<dt>ctx:</dt>
<dd style="margin-left: 8">Context that can contain properties of this socket/connection and retains them across function calls. This function is mostly called with an empty context, which is then filled within the function.</dd>
<dt>hostname:</dt>
<dd style="margin-left: 8">Remote host name to be resolved</dd>
<dt>servname:</dt>
<dd style="margin-left: 8">Remote service to be resolved</dd>
<dt>hints:</dt>
<dd style="margin-left: 8">Hints for resolving the name</dd>
<dt>res:</dt>
<dd style="margin-left: 8">Data structure for result of name resolution</dd>
</dl>
<p id="rfc.section.5.1.1.p.6">RETURN VALUE:</p>
<p id="rfc.section.5.1.1.p.7">Returns 0 on success, or an error code as provided by getaddrinfo().</p>
<h1 id="rfc.section.5.1.2">
<a href="#rfc.section.5.1.2">5.1.2.</a> <a href="#muaccsocket" id="muaccsocket">muacc_socket()</a>
</h1>
<p id="rfc.section.5.1.2.p.1">This function creates a socket file descriptor just like the regular socket call.</p>
<p id="rfc.section.5.1.2.p.2">SIGNATURE:</p>
<p id="rfc.section.5.1.2.p.3">int muacc_socket(muacc_context_t *ctx, int domain, int type, int protocol)</p>
<p id="rfc.section.5.1.2.p.4">ARGUMENTS:</p>
<p></p>

<dl>
<dt>ctx:</dt>
<dd style="margin-left: 8">Context that can contain properties of this socket/connection and retains them across function calls. This function is mostly called after muacc_getaddrinfo(), since domain, type, and protocol can depend on the type of resolved address.</dd>
<dt>domain:</dt>
<dd style="margin-left: 8">Domain of the socket</dd>
<dt>type:</dt>
<dd style="margin-left: 8">Type of the socket</dd>
<dt>protocol:</dt>
<dd style="margin-left: 8">Protocol of the socket</dd>
</dl>
<p id="rfc.section.5.1.2.p.6">RETURN VALUE:</p>
<p id="rfc.section.5.1.2.p.7">Returns a file descriptor of the new socket on success, or -1 on failure.</p>
<h1 id="rfc.section.5.1.3">
<a href="#rfc.section.5.1.3">5.1.3.</a> <a href="#muaccsetsockopt" id="muaccsetsockopt">muacc_setsockopt()</a>
</h1>
<p id="rfc.section.5.1.3.p.1">This call allows to set socket options (including Socket Intents).  For Socket Intents, this function can be called on a valid <samp>muacc_context</samp> and an invalided file descriptor (-1) to provide assertional hints to <samp>muacc_getaddrinfo()</samp>.</p>
<p id="rfc.section.5.1.3.p.2">SIGNATURE:</p>
<p id="rfc.section.5.1.3.p.3">int muacc_setsockopt(muacc_context_t *ctx, int socket, int level, int option_name, const void *option_value, socklen_t option_len)</p>
<p id="rfc.section.5.1.3.p.4">ARGUMENTS:</p>
<p></p>

<dl>
<dt>ctx:</dt>
<dd style="margin-left: 8">Context that can contain properties of this socket/connection and retains them across function calls. This function is mostly called to set Intents as socket options within the context.</dd>
<dt>socket:</dt>
<dd style="margin-left: 8">Socket file descriptor</dd>
<dt>level:</dt>
<dd style="margin-left: 8">Level of the socket option to set</dd>
<dt>option_name:</dt>
<dd style="margin-left: 8">Name of the socket option to set</dd>
<dt>option_value:</dt>
<dd style="margin-left: 8">Value of the socket option to set</dd>
<dt>option_len:</dt>
<dd style="margin-left: 8">Length of the socket option to set</dd>
</dl>
<p id="rfc.section.5.1.3.p.6">RETURN VALUE:</p>
<p id="rfc.section.5.1.3.p.7">Returns 0 on success, or -1 on failure.</p>
<h1 id="rfc.section.5.1.4">
<a href="#rfc.section.5.1.4">5.1.4.</a> <a href="#muaccconnect" id="muaccconnect">muacc_connect()</a>
</h1>
<p id="rfc.section.5.1.4.p.1">Like the regular connect call, but also binds to the source address selected by the Socket Intents Policy and applies socket options suggested by the Socket Intents Policy.</p>
<p id="rfc.section.5.1.4.p.2">SIGNATURE:</p>
<p id="rfc.section.5.1.4.p.3">int muacc_connect(muacc_context_t *ctx, int socket, const struct sockaddr *address, socklen_t address_len)</p>
<p id="rfc.section.5.1.4.p.4">ARGUMENTS:</p>
<p></p>

<dl>
<dt>ctx:</dt>
<dd style="margin-left: 8">Context that can contain properties of this socket/connection and retains them across function calls. This function is mostly called after all Socket Intents for this connection have been set via muacc_setsockopt().</dd>
<dt>socket:</dt>
<dd style="margin-left: 8">Socket file descriptor</dd>
<dt>address:</dt>
<dd style="margin-left: 8">Remote address to connect to</dd>
<dt>address_len:</dt>
<dd style="margin-left: 8">Length of the remote address</dd>
</dl>
<p id="rfc.section.5.1.4.p.6">RETURN VALUE:</p>
<p id="rfc.section.5.1.4.p.7">Returns 0 on success, or -1 on failure.</p>
<h1 id="rfc.section.5.1.5">
<a href="#rfc.section.5.1.5">5.1.5.</a> <a href="#muaccclose" id="muaccclose">muacc_close()</a>
</h1>
<p id="rfc.section.5.1.5.p.1">Like regular close, but also cleans up state held in shadow structures behind <samp>muacc_context</samp></p>
<p id="rfc.section.5.1.5.p.2">SIGNATURE:</p>
<p id="rfc.section.5.1.5.p.3">int muacc_close(muacc_context_t *ctx, int socket)</p>
<p id="rfc.section.5.1.5.p.4">ARGUMENTS:</p>
<p></p>

<dl>
<dt>ctx:</dt>
<dd style="margin-left: 8">Context that can contain properties of this socket/connection and retains them across function calls. This function deinitializes and releases the context.</dd>
<dt>socket:</dt>
<dd style="margin-left: 8">Socket file descriptor</dd>
</dl>
<p id="rfc.section.5.1.5.p.6">RETURN VALUE:</p>
<p id="rfc.section.5.1.5.p.7">Returns 0 on success, or -1 on failure.</p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#getaddrinfoapi" id="getaddrinfoapi">Classic API / getaddrinfo</a>
</h1>
<p id="rfc.section.5.2.p.1">In this variant, Socket Intents are passed directly to <samp>getaddrinfo()</samp> as part of the <samp>hints</samp> parameter.  The name resolution is done by the MAM, which makes all decisions and stores them in the &#8220;result&#8221; data structure as list of options ordered by preference.  Subsequently, applications can use this information for calls to the unmodified BSD Socket API or other APIs.  We provide helpers to apply all socket options from the &#8220;result&#8221; data structure.</p>
<p id="rfc.section.5.2.p.2">All relevant infos are stored in our addrinfo struct (see <a href="#muacc_addrinfo" class="xref">Figure 2</a>)</p>
<p id="rfc.section.5.2.p.3">SIGNATURE:</p>
<p id="rfc.section.5.2.p.4">int muacc_ai_getaddrinfo(const char * hostname, const char * service, const struct muacc_addrinfo * hints, struct muacc_addrinfo ** result)</p>
<p id="rfc.section.5.2.p.5">ARGUMENTS:</p>
<p></p>

<dl>
<dt>hostname:</dt>
<dd style="margin-left: 8">Remote host name to be resolved</dd>
<dt>service:</dt>
<dd style="margin-left: 8">Remote service to be resolved</dd>
<dt>hints:</dt>
<dd style="margin-left: 8">Hints for resolving the name. Contents include family, socket type, protocol, socket options (including Socket Intents for this socket/connection), local address to bind to.</dd>
<dt>result:</dt>
<dd style="margin-left: 8">Data structure for result of name resolution</dd>
</dl>
<p id="rfc.section.5.2.p.7">RETURN VALUE:</p>
<p id="rfc.section.5.2.p.8">Returns 0 on success, or an error code as provided by getaddrinfo().</p>
<div id="rfc.figure.2"></div>
<div id="muacc_addrinfo"></div>
<pre>
/** Extended version of the standard library's struct addrinfo
 *
 * This is used both as hint and as result from the
 * muacc_ai_getaddrinfo * function. This structure
 * differs from struct addrinfo only in the three members
 * ai_bindaddrlen, ai_bindaddr and ai_socketopt.
 */
struct muacc_addrinfo {
    int ai_flags;
    int ai_family;
    int ai_socktype;
    int ai_protocol;

    /** Not included in struct addrinfo. Purpose:
      * 1. If the structure is given to muacc_ai_getaddrinfo
      *    as hints, you set socket intents that influence MAM's
      *    source and destination as well as transport protocol
      *    selection
      * 2. The recommended socket options MAM will be returned
      *    through this attribute.
      */
    struct socketopt *ai_sockopts;

    int ai_addrlen;
    struct sockaddr *ai_addr;
    char *ai_canonname;

    /** Not included in struct addrinfo.
      * Length of ai_bindaddr.
      */
    int ai_bindaddrlen;
    /** Not included in struct addrinfo.
      * Contains the address, which the MAM recommends us to bind to.
      */
    struct sockaddr *ai_bindaddr;

    struct muacc_addrinfo *ai_next;
};
</pre>
<p class="figure">Figure 2: Definition of the muacc_addrinfo struct</p>
<p><a href="#getaddrinfo_api_example" class="xref">Appendix A.2</a> shows an example usage of the classic API with most functionality in getaddrinfo.</p>
<h1 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> <a href="#socketconnectapi" id="socketconnectapi">Socketconnect API</a>
</h1>
<p id="rfc.section.5.3.p.1">In this API variant, we move the functionality of resolving a hostname and connecting to the resulting address into one function called <samp>socketconnect()</samp>.  This API makes it possible to call socketconnect not only for each connection, but also to multiplex messages across multiple existing sockets.</p>
<p id="rfc.section.5.3.p.2">This function returns a file descriptor of a connected socket for the application to use.  This socket can either be a newly created one or a socket that existed previously and is now being reused.  Furthermore, a socket can belong to a socket set of sockets with common destination and service.  These sockets may, e.g., be bound to different local addresses, but are treated as interchangeable by the API implementation.  So if the application passes a socket file descriptor to this function, it may get back a different file descriptor to a socket from the same set, e.g., to use the connection over a different local interface for its following communication.</p>
<p id="rfc.section.5.3.p.3">SIGNATURE:</p>
<p id="rfc.section.5.3.p.4">int socketconnect(int *socket, const char *host, size_t hostlen, const char *serv, size_t servlen, struct socketopt *sockopts, int domain, int type, int proto)</p>
<p id="rfc.section.5.3.p.5">ARGUMENTS:</p>
<p></p>

<dl>
<dt>socket:</dt>
<dd style="margin-left: 8">Existing socket file descriptor as representant to a socket set, &#8220;-1&#8221; to create a new socket, or &#8220;0&#8221; to automatically try to find a suitable socket set</dd>
<dt>host:</dt>
<dd style="margin-left: 8">Remote hostname to be resolved</dd>
<dt>hostlen:</dt>
<dd style="margin-left: 8">Length of remote hostname</dd>
<dt>serv:</dt>
<dd style="margin-left: 8">Remote service or port</dd>
<dt>servlen:</dt>
<dd style="margin-left: 8">Length of remote service</dd>
<dt>socketopts:</dt>
<dd style="margin-left: 8">List of socket options, including Socket Intents</dd>
<dt>domain:</dt>
<dd style="margin-left: 8">Domain of the socket</dd>
<dt>type:</dt>
<dd style="margin-left: 8">Type of the socket</dd>
<dt>proto:</dt>
<dd style="margin-left: 8">Protocol of the socket</dd>
</dl>
<p id="rfc.section.5.3.p.7">RETURN VALUE:</p>
<p id="rfc.section.5.3.p.8">Returns 0 on success if socket is from an existing socket set, 1 on success if socket was newly created, or -1 on fail.</p>
<p><a href="#socketconnect_api_example" class="xref">Appendix A.3</a> shows an example usage of the Socketconnect API.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#api-implementation-experiences-lessons-learned" id="api-implementation-experiences-lessons-learned">API Implementation Experiences &amp; Lessons Learned</a>
</h1>
<p id="rfc.section.6.p.1">While designing and implementing the different parts of the system as described in this document, we faced several challenges.  In the Multiple Access Manager discovering the currently available paths and statistics about their performance turned out to be quite complex and had to be implemented in a partially platform-dependent way.  However, the most challenging parts were the Socket Intents API and Library, on which we focus in the following sections.</p>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> <a href="#namereslink" id="namereslink">The Missing Link to Name Resolution</a>
</h1>
<p id="rfc.section.6.1.p.1">Transport option selection is most useful if crucial information, such as Socket Intents or other socket options, is available as early as possible, i.e., for name resolution. The primary problem here is the order of the function calls that are involved in name resolution, destination selection, protocol, and path selection, and how they are linked.</p>
<p id="rfc.section.6.1.p.2">In the classic BSD Socket API, most functions either take a socket file descriptor as argument or return it, and thus link different function calls to the same flow. However, <samp>getaddrinfo()</samp> is not linked to a socket file descriptor, and it is typically called before the socket is created. At this point, it is not yet possible to set a socket option, because the socket does not exist yet.</p>
<p id="rfc.section.6.1.p.3">Consequently, across BSD Socket API calls, several choices are being made before it is possible to set a Socket Intent: A call to <samp>getaddrinfo()</samp> returns a linked list of <samp>addrinfo</samp> structs, where each entry contains an <samp>ai_family</samp> (IP version), the pair of <samp>ai_socktype</samp> and <samp>ai_protocol</samp> (transport protocol), and a <samp>sockaddr</samp> struct containing an IP address and port to connect to. Then a socket of the given family, type, and protocol is created. Only after this has been done, socket options can be set on the socket, but at this point destination, IP version, and transport protocol are already fixed.  Before calling <samp>connect()</samp>, only the path to be used (i.e., the local address to bind to) can still be chosen, but the available paths and which one to prefer may be constrained by the choice of destination.</p>
<p id="rfc.section.6.1.p.4">The three variants described in <a href="#apivar" class="xref">Section 5</a> work around this problem in different ways:</p>
<p></p>

<ul>
<li>The approach in <a href="#getaddrinfoapi" class="xref">Section 5.2</a> places the whole automation of transport option selection into the <samp>getaddrinfo()</samp> function.  The results are returned in an extended <samp>addrinfo</samp> struct and have to be applied manually by the application, including binding to a source address representing the selected path and applying all socket options provided in a list, for each connection attempt.</li>
<li>The approach in <a href="#muacccontextapi" class="xref">Section 5.1</a> adds a context to all socket- and name resolution-related API calls.</li>
<li>The approach in <a href="#socketconnectapi" class="xref">Section 5.3</a> puts all functionality into one call.</li>
</ul>
<p id="rfc.section.6.1.p.6">All of these approaches add the missing link between name resolution and the other parts of the API, but add a lot of state keeping either to the API, which the application developer has to manage, or to the Socket Intents library.</p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> <a href="#fdharm" id="fdharm">File Descriptors Considered Harmful</a>
</h1>
<p id="rfc.section.6.2.p.1">When using BSD sockets, file descriptors are the abstraction for network flows.  Depending on the transport protocol used, their semantics changes and these file handles represent streams (SOCK_STREAM), associations (SOCK_DRAM) or network interfaces (SOCK_RAW). This does not provide a unified API, but is merely an artifact of squeezing networking into the &#8220;Everything is a file&#8221; UNIX philosophy.</p>
<p id="rfc.section.6.2.p.2">File descriptors make no good abstraction for automated protocol stack instance selection as applications have to adopt to changed semantics, e.g., whether message boundaries are preserved, depending on the transport protocol chosen.</p>
<p id="rfc.section.6.2.p.3">File descriptors make no good abstraction for destination instance selection and path selection either.  Once a socket has been created, its protocol stack instance is fixed, so selecting a path by binding to a local address and connecting to a destination instance is now only possible using this protocol stack instance. If such a connection attempt fails, it is possible to retry using another path and destination, but changing the protocol stack instance requires creating a new socket with a different file descriptor.</p>
<p id="rfc.section.6.2.p.4">For further discussion of other asynchronous I/O weirdness with file descriptors see end of <a href="#async-api" class="xref">Section 6.3</a>.</p>
<h1 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> <a href="#async-api" id="async-api">Asynchronous API Anarchy</a>
</h1>
<p id="rfc.section.6.3.p.1">Network I/O is asynchronous, but asynchronous I/O within the POSIX filesystem API is hard to use. There are at least three different asynchronous I/O APIs for each operating system.</p>
<p id="rfc.section.6.3.p.2">To implement asynchronous I/O for our Socket Intents prototype, we wrapped one of the asynchronous I/O APIs that is available on most platforms: <samp>select()</samp>.  To make Socket Intents accessible to more applications and on more platforms, a production-grade system would need to wrap all asynchronous I/O APIs and implement most of the socket creation logic, path selection and connection logic within these wrappers.  However, mixing asynchronous I/O and multithreading may lead to unintuitive behavior, e.g., calling our prototype&#8217;s select() from different threads could lead to anything from deadlocks to busy waiting.</p>
<p id="rfc.section.6.3.p.3">Another issue is that we use Unix domain sockets to communicate between our Multiple Access Manager and the Socket Intents API library called by the application, so we need to make sure that the application does not block on communication with the Multiple Access Manager.</p>
<p id="rfc.section.6.3.p.4">Also the problems with using file descriptors get even worse.  If a Socket API call should return immediately, it needs to provide the application with a reference to a flow that has not yet been fully set up, i.e., a reference to a &#8220;future&#8221; socket.  An implementation of such an asynchronous API has to return an unconnected socket file descriptor, on which the application then calls, e.g., <samp>select()</samp>, and starts using it once it becomes readable and writable.  If the destination, path and transport protocol have not been chosen yet at this point, the file descriptor returned by the implementation might not yet have the final family and transport protocol.  When the implementation later creates the final socket of the right type, it can re-bind it to the file-id of the originally returned file descriptor using <samp>dup2</samp>.  This procedure can easily lead to time-of-check to time-of-use confusion.  To make things even worse, the application can copy the &#8220;future&#8221; file descriptor using <samp>dup</samp>, which is rarely useful for sockets, but in combination with file descriptors used as &#8220;future&#8221; it leads to unexpected behavior.</p>
<h1 id="rfc.section.6.4">
<a href="#rfc.section.6.4">6.4.</a> <a href="#here-be-dragons-hiding-in-shadow-structures" id="here-be-dragons-hiding-in-shadow-structures">Here Be Dragons hiding in Shadow Structures</a>
</h1>
<p id="rfc.section.6.4.p.1">The API variants described in <a href="#socketconnectapi" class="xref">Section 5.3</a> and <a href="#muacccontextapi" class="xref">Section 5.1</a> need to keep a lot of state in shadow structures that cannot be passed between the Socket API calls otherwise.  This state needs to be cleaned up when the last copy of the file descriptor is closed or the last socket held for reuse has timed out.  In addition, access to these shadow structures has to be thread-safe.</p>
<p id="rfc.section.6.4.p.2">Implementing both has turned out to be extremely error-prone and there is a high amount of unspecified behavior and platform-dependent extensions in the system library. These issues guarantee that an implementation of transport option selection that nicely integrates with BSD Sockets will come with lots of limitations and will not be portable across POSIX-compliant operating systems.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#conclusion" id="conclusion">Conclusion</a>
</h1>
<p id="rfc.section.7.p.1">Adding transport option selection to BSD Sockets is hard, as the API calls are not designed to defer making and applying choices to a moment where all information needed for transport option selection is available.</p>
<p id="rfc.section.7.p.2">After all, if limiting transport option selection to the granularity BSD Sockets typically provide today (TCP connections and UDP associations), the API variant described in <a href="#getaddrinfoapi" class="xref">Section 5.2</a> seems to be a good compromise, even if it forces the application to try all candidates itself (either in a sequential or partial parallel fashion).  This option is easily deployable, but does not include automation of techniques like connection caching or HTTP pipelining.</p>
<p id="rfc.section.7.p.3">The most versatile API variant described in <a href="#socketconnectapi" class="xref">Section 5.3</a> implements connection caching on the transport layer.  This comes at the cost of heavily modifying existing applications.  If feasible, given the unnecessary complexity of the file I/O integration of BSD sockets, it seems easier to move to a totally different system like <a href="#I-D.trammell-taps-post-sockets" class="xref">[I-D.trammell-taps-post-sockets]</a>.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#acknowledgments" id="acknowledgments">Acknowledgments</a>
</h1>
<p id="rfc.section.8.p.1">Thanks to Tobias Kaiser <a href="mailto:mail@tb-kaiser.de">mail@tb-kaiser.de</a> for drafting and implementing the API variant described in <a href="#getaddrinfoapi" class="xref">Section 5.2</a> as part of his BA thesis.</p>
<h1 id="rfc.references">
<a href="#rfc.references">9.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="ANRW17-MH">[ANRW17-MH]</b></td>
<td class="top">
<a>Tiesel, P.</a>, <a>May, B.</a> and <a>A. Feldmann</a>, "<a>Multi-Homed on a Single Link</a>", Proceedings of the 2016 workshop on Applied Networking Research Workshop - ANRW 16 , DOI 10.1145/2959424.2959434, 2016.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.tiesel-taps-communitgrany">[I-D.tiesel-taps-communitgrany]</b></td>
<td class="top">
<a>Tiesel, P.</a> and <a>T. Enghardt</a>, "<a href="http://tools.ietf.org/html/draft-tiesel-taps-communitgrany-00">Communication Units Granularity Considerations for Multi-Path Aware Transport Selection</a>", Internet-Draft draft-tiesel-taps-communitgrany-00, June 2017.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.tiesel-taps-socketintents">[I-D.tiesel-taps-socketintents]</b></td>
<td class="top">
<a>Tiesel, P.</a> and <a>T. Enghardt</a>, "<a href="http://tools.ietf.org/html/draft-tiesel-taps-socketintents-00">Socket Intents</a>", Internet-Draft draft-tiesel-taps-socketintents-00, June 2017.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.trammell-taps-post-sockets">[I-D.trammell-taps-post-sockets]</b></td>
<td class="top">
<a>Trammell, B.</a>, <a>Perkins, C.</a>, <a>Pauly, T.</a> and <a>M. Kuehlewind</a>, "<a href="http://tools.ietf.org/html/draft-trammell-taps-post-sockets-00">Post Sockets, An Abstract Programming Interface for the Transport Layer</a>", Internet-Draft draft-trammell-taps-post-sockets-00, March 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6824">[RFC6824]</b></td>
<td class="top">
<a>Ford, A.</a>, <a>Raiciu, C.</a>, <a>Handley, M.</a> and <a>O. Bonaventure</a>, "<a href="http://tools.ietf.org/html/rfc6824">TCP Extensions for Multipath Operation with Multiple Addresses</a>", RFC 6824, DOI 10.17487/RFC6824, January 2013.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7413">[RFC7413]</b></td>
<td class="top">
<a>Cheng, Y.</a>, <a>Chu, J.</a>, <a>Radhakrishnan, S.</a> and <a>A. Jain</a>, "<a href="http://tools.ietf.org/html/rfc7413">TCP Fast Open</a>", RFC 7413, DOI 10.17487/RFC7413, December 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7556">[RFC7556]</b></td>
<td class="top">
<a>Anipko, D.</a>, "<a href="http://tools.ietf.org/html/rfc7556">Multiple Provisioning Domain Architecture</a>", RFC 7556, DOI 10.17487/RFC7556, June 2015.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#api-usage-examples" id="api-usage-examples">API Usage Examples</a>
</h1>
<h1 id="rfc.appendix.A.1">
<a href="#rfc.appendix.A.1">A.1.</a> <a href="#classic_api_example" id="classic_api_example">Usage Example of the Classic / muacc_context API</a>
</h1>
<p id="rfc.section.A.1.p.1">In this example, a client application sets up a connection to a remote host and sends data to it. It specifies two Socket Intents on this connection: The Category of Bulk Transfer and the File Size of 1 MB.</p>
<pre>
#define LENGTH_OF_DATA 1048576

// Create and initialize a context to retain information across function
// calls
muacc_context_t ctx;
muacc_init_context(&amp;ctx);

int socket = -1;

struct addrinfo *result = NULL;

// Initialize a buffer of data to send later.
char buf[LENGTH_OF_DATA];
memset(&amp;buf, 0, LENGTH_OF_DATA);

// Set Socket Intents for this connection. Note that the "socket" is
// still invalid, but it does not yet need to exist at this time. The
// Socket Intents prototype just sets the Intent within the
// muacc_context data structure.

enum intent_category category = INTENT_BULKTRANSFER;
muacc_setsockopt(&amp;ctx, socket, SOL_INTENTS,
    INTENT_CATEGORY, &amp;category, sizeof(enum intent_category));

int filesize = LENGTH_OF_DATA;
muacc_setsockopt(&amp;ctx, socket, SOL_INTENTS,
    INTENT_FILESIZE, &amp;filesize, sizeof(int));


// Resolve a host name. This involves a request to the MAM, which can
// automatically choose a suitable local interface or other parameters
// for the DNS request and set other parameters, such as preferred
// address family or transport protocol.
muacc_getaddrinfo(&amp;ctx, "example.org", NULL, NULL, &amp;result);

// Create the socket with the address family, type, and protocol
// obtained by getaddrinfo.
socket = muacc_socket(&amp;ctx, result-&gt;ai_family, result-&gt;ai_socktype,
    result-&gt;ai_protocol);

// Connect the socket to the remote endpoint as determined by
// getaddrinfo.  This involves another request to MAM, which may at this
// point, e.g., choose to bind the socket to a local IP address before
// connecting it.
muacc_connect(&amp;ctx, socket, result-&gt;ai_addr, result-&gt;ai_addrlen);

// Send data to the remote host over the socket.
write(socket, &amp;buf, LENGTH_OF_DATA);

// Close the socket. This de-initializes any data that was stored within
// the muacc_context.
muacc_close(&amp;ctx, socket);

</pre>
<h1 id="rfc.appendix.A.2">
<a href="#rfc.appendix.A.2">A.2.</a> <a href="#getaddrinfo_api_example" id="getaddrinfo_api_example">Usage Example of the Classic / getaddrinfo API</a>
</h1>
<p id="rfc.section.A.2.p.1">As in <a href="#classic_api_example" class="xref">Appendix A.1</a>, the application sets the Intents &#8220;Category&#8221; and &#8220;File Size&#8221;.</p>
<pre>
#define LENGTH_OF_DATA 1048576

// Define Intents to be set later
enum intent_category category = INTENT_BULKTRANSFER;
int filesize = LENGTH_OF_DATA;

struct socketopt intents = { .level = SOL_INTENTS,
    .optname = INTENT_CATEGORY, .optval = &amp;category, .next = NULL};
struct socketopt filesize_intent = { .level = SOL_INTENTS,
    .optname = INTENT_FILESIZE, .optval = &amp;filesize, .next = NULL};

intents.next = &amp;filesize_intent;

// Initialize a buffer of data to send later.
char buf[LENGTH_OF_DATA];
memset(&amp;buf, 0, LENGTH_OF_DATA);

struct muacc_addrinfo intent_hints = { .ai_flags = 0,
    .ai_family = AF_INET, .ai_socktype = SOCK_STREAM, .ai_protocol = 0,
    .ai_sockopts = &amp;intents, .ai_addr = NULL, .ai_addrlen = 0,
    .ai_bindaddr = NULL, .ai_bindaddrlen = 0, .ai_next = NULL };

struct muacc_addrinfo *result = NULL;

muacc_ai_getaddrinfo("example.org", NULL, &amp;intent_hints,
    &amp;result);

// Create and connect the socket, using the information obtained through
// getaddrinfo
int fd;
fd = socket(result-&gt;ai_family, result-&gt;ai_socktype,
    result-&gt;ai_protocol);
muacc_ai_simple_connect(fd, result);

// Send data to the remote host over the socket, then close it.
write(fd, &amp;buf, LENGTH_OF_DATA);
close(fd);

muacc_ai_freeaddrinfo(result);

</pre>
<h1 id="rfc.appendix.A.3">
<a href="#rfc.appendix.A.3">A.3.</a> <a href="#socketconnect_api_example" id="socketconnect_api_example">Usage Example of the Socketconnect API</a>
</h1>
<p id="rfc.section.A.3.p.1">As in <a href="#classic_api_example" class="xref">Appendix A.1</a>, the application sets the Intents &#8220;Category&#8221; and &#8220;File Size&#8221;.  As we provide <samp>-1</samp> as socket, no we do not reuse existing connections.</p>
<pre>
#define LENGTH_OF_DATA 1048576

// Define Intents to be set later
enum intent_category category = INTENT_BULKTRANSFER;
int filesize = LENGTH_OF_DATA;

struct socketopt intents = { .level = SOL_INTENTS,
    .optname = INTENT_CATEGORY, .optval = &amp;category, .next = NULL};
struct socketopt filesize_intent = { .level = SOL_INTENTS,
    .optname = INTENT_FILESIZE, .optval = &amp;filesize, .next = NULL};

intents.next = &amp;filesize_intent;

// Initialize a buffer of data to send later.
char buf[LENGTH_OF_DATA];
memset(&amp;buf, 0, LENGTH_OF_DATA);

int socket = -1;

// Get a socket that is connected to the given host and service,
// with the given Intents
socketconnect(&amp;socket, "example.org", 11, "80", 2, &amp;intents, AF_INET,
    SOCK_STREAM, 0);

// Send data to the remote host over the socket.
write(socket, &amp;buf, LENGTH_OF_DATA);

// Close the socket and tear down the data structure kept for it
// in the library
socketclose(socket);
</pre>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Philipp S. Tiesel</span> 
	  <span class="n hidden">
		<span class="family-name">Tiesel</span>
	  </span>
	</span>
	<span class="org vcardline">Berlin Institute of Technology</span>
	<span class="adr">
	  <span class="vcardline">Marchstr. 23</span>

	  <span class="vcardline">
		<span class="locality">Berlin</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Germany</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:philipp@inet.tu-berlin.de">philipp@inet.tu-berlin.de</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Theresa Enghardt</span> 
	  <span class="n hidden">
		<span class="family-name">Enghardt</span>
	  </span>
	</span>
	<span class="org vcardline">Berlin Institute of Technology</span>
	<span class="adr">
	  <span class="vcardline">Marchstr. 23</span>

	  <span class="vcardline">
		<span class="locality">Berlin</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Germany</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:theresa@inet.tu-berlin.de">theresa@inet.tu-berlin.de</a></span>

  </address>
</div>

</body>
</html>
